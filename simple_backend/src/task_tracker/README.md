## Минусы хранения задач в оперативной памяти (списке Python)

### 1. Ограничение по объёму памяти
Оперативная память (ОЗУ) имеет ограниченный объём.  
При превышении доступной памяти (из-за большого количества задач или их размера) программа может:
- Завершиться с ошибкой (`MemoryError`).  
- Сильно замедлиться из-за свопа (использования диска под кеш).  

### 2. Потеря данных при сбое
Данные в ОЗУ **не сохраняются** при:
- Перезагрузке компьютера.  
- Аварийном завершении программы.  
- Обновлении сервера.  

**Последствие**: Все невыполненные задачи будут безвозвратно утеряны.  


### 3. Не подходит для постоянного хранения
ОЗУ — это временное хранилище. Для долговременного сохранения задач необходимо использовать:  
- **Базы данных**: SQLite, PostgreSQL, MySQL.  
- **Файловое хранилище**: JSON, CSV (с риском потери при параллельной записи).  
- **Специализированные решения**: Redis (с персистентностью), Apache Kafka.  




# Изменения в системе хранения задач

## Переход с оперативной памяти на файловое хранилище (JSON)

### Что улучшилось:
1. **Сохранение данных между запусками**  
   - Данные больше не теряются при перезапуске программы или сервера
   - История задач сохраняется на диске

2. **Надёжность хранения**  
   - Устранены риски потери данных при сбоях питания
   - Возможность делать бэкапы файла с задачами

### ❗ Осталось ли хранение состояния?
Нет, мы **не избавились** от хранения состояния полностью, но:
- Состояние теперь сохраняется между сеансами работы программы
- Состояние стало персистентным (сохраняемым на диск)
- По-прежнему требуется управление состоянием в runtime

## Альтернативные способы хранения задач

### 1. Реляционные БД (SQLite, PostgreSQL)
**Преимущества:**
- Надёжность и целостность данных
- Сложные запросы и фильтрация
- Поддержка транзакций

**Недостатки:**
- Требуют больше настроек
- Избыточны для простых проектов

### 2. Документоориентированные БД (MongoDB)
**Преимущества:**
- Гибкая схема данных
- Хорошая масштабируемость
- Поддержка JSON-документов

**Недостатки:**
- Требует отдельного сервера
- Нет JOIN и сложных транзакций

### 3. Ключ-значение хранилища (Redis)
**Преимущества:**
- Высокая производительность
- Поддержка разных структур данных
- Персистентность при необходимости

**Недостатки:**
- Данные в памяти (ограничение по объёму)
- Требует отдельного сервера

### 4. Файловые хранилища (JSON, CSV)
**Преимущества:**
- Простота реализации
- Человекочитаемый формат
- Не требует дополнительных серверов

**Недостатки:**
- Проблемы с конкурентным доступом
- Ограниченные возможности запросов
- Медленнее БД при больших объёмах

## Текущая реализация
Мы используем **JSON-файл** как оптимальное решение для:
- Небольших и средних проектов
- Ситуаций, когда важна простота развёртывания
- Проектов, где человекочитаемый формат является преимуществом




## Проблемы в текущей реализации

### 1. Отсутствие потокобезопасности

**Проблема:**  
FastAPI обрабатывает запросы асинхронно, но `tasks` хранится в памяти и обновляется через `requests.put()`.

**Риск:**  
При одновременном изменении `tasks` двумя запросами возможны:
- Некорректная перезапись данных в JSONBin.io
- Потеря изменений одного из запросов
- Непредсказуемое поведение системы

### 2. Нет блокировки ресурсов

**Проблема:**  
Отсутствует механизм блокировки доступа к `tasks` во время операций обновления.

**Пример сценария:**
1. Пользователь 1 начинает обновление задачи
2. Пользователь 2 одновременно удаляет эту же задачу
3. Возможные последствия:
   - Потеря данных (частичное применение изменений)
   - Ошибка 500 (сервер не может обработать конфликт)
   - Повреждение структуры данных

### 3. Отсутствие транзакционности

**Проблема:**  
Нет атомарности операций между локальным состоянием и облачным хранилищем.

**Критический сценарий:**
1. Локальный список `tasks` успешно обновляется
2. Запрос к JSONBin.io завершается с ошибкой
3. Результат:
   - Локальное состояние и облачное хранилище расходятся
   - Данные становятся противоречивыми
   - Невозможно восстановить согласованность без ручного вмешательства

**Последствия:**  
Система не гарантирует целостность данных при сбоях сети или сервера.


## 3. Решения

### 3.1. Блокировки (Locking)

**Решение:**  
Использование `asyncio.Lock` для синхронизации доступа к общему ресурсу:

```python
from fastapi import FastAPI
import asyncio

app = FastAPI()
tasks_lock = asyncio.Lock()

@app.post("/tasks")
async def create_task(task: Task):
    async with tasks_lock:  # Блокируем доступ
        tasks.append(task)
        await update_jsonbin()  # Обновляем хранилище
    return task


## 3.2. Оптимистичная блокировка (Optimistic Concurrency Control)

### Решение
Использование механизма версионности данных для контроля изменений. Перед внесением изменений проверяется, не были ли данные изменены другим процессом с момента их чтения.

**Пример реализации:**
```python
# Получаем текущую версию данных из хранилища
response = requests.get(URL, headers=headers)
current_version = response.json()["metadata"]["version"]

# Проверяем, что данные не изменились
if current_version != expected_version:
    raise HTTPException(
        status_code=409,
        detail="Данные были изменены другим пользователем. Обновите страницу и попробуйте снова."
    )